<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>tracing.rs.html -- source</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../../../boehm/main.css">

    
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        

        
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content source"><pre class='line-numbers'><span id='1'>  1</span>
<span id='2'>  2</span>
<span id='3'>  3</span>
<span id='4'>  4</span>
<span id='5'>  5</span>
<span id='6'>  6</span>
<span id='7'>  7</span>
<span id='8'>  8</span>
<span id='9'>  9</span>
<span id='10'> 10</span>
<span id='11'> 11</span>
<span id='12'> 12</span>
<span id='13'> 13</span>
<span id='14'> 14</span>
<span id='15'> 15</span>
<span id='16'> 16</span>
<span id='17'> 17</span>
<span id='18'> 18</span>
<span id='19'> 19</span>
<span id='20'> 20</span>
<span id='21'> 21</span>
<span id='22'> 22</span>
<span id='23'> 23</span>
<span id='24'> 24</span>
<span id='25'> 25</span>
<span id='26'> 26</span>
<span id='27'> 27</span>
<span id='28'> 28</span>
<span id='29'> 29</span>
<span id='30'> 30</span>
<span id='31'> 31</span>
<span id='32'> 32</span>
<span id='33'> 33</span>
<span id='34'> 34</span>
<span id='35'> 35</span>
<span id='36'> 36</span>
<span id='37'> 37</span>
<span id='38'> 38</span>
<span id='39'> 39</span>
<span id='40'> 40</span>
<span id='41'> 41</span>
<span id='42'> 42</span>
<span id='43'> 43</span>
<span id='44'> 44</span>
<span id='45'> 45</span>
<span id='46'> 46</span>
<span id='47'> 47</span>
<span id='48'> 48</span>
<span id='49'> 49</span>
<span id='50'> 50</span>
<span id='51'> 51</span>
<span id='52'> 52</span>
<span id='53'> 53</span>
<span id='54'> 54</span>
<span id='55'> 55</span>
<span id='56'> 56</span>
<span id='57'> 57</span>
<span id='58'> 58</span>
<span id='59'> 59</span>
<span id='60'> 60</span>
<span id='61'> 61</span>
<span id='62'> 62</span>
<span id='63'> 63</span>
<span id='64'> 64</span>
<span id='65'> 65</span>
<span id='66'> 66</span>
<span id='67'> 67</span>
<span id='68'> 68</span>
<span id='69'> 69</span>
<span id='70'> 70</span>
<span id='71'> 71</span>
<span id='72'> 72</span>
<span id='73'> 73</span>
<span id='74'> 74</span>
<span id='75'> 75</span>
<span id='76'> 76</span>
<span id='77'> 77</span>
<span id='78'> 78</span>
<span id='79'> 79</span>
<span id='80'> 80</span>
<span id='81'> 81</span>
<span id='82'> 82</span>
<span id='83'> 83</span>
<span id='84'> 84</span>
<span id='85'> 85</span>
<span id='86'> 86</span>
<span id='87'> 87</span>
<span id='88'> 88</span>
<span id='89'> 89</span>
<span id='90'> 90</span>
<span id='91'> 91</span>
<span id='92'> 92</span>
<span id='93'> 93</span>
<span id='94'> 94</span>
<span id='95'> 95</span>
<span id='96'> 96</span>
<span id='97'> 97</span>
<span id='98'> 98</span>
<span id='99'> 99</span>
<span id='100'>100</span>
<span id='101'>101</span>
<span id='102'>102</span>
<span id='103'>103</span>
<span id='104'>104</span>
<span id='105'>105</span>
<span id='106'>106</span>
<span id='107'>107</span>
<span id='108'>108</span>
<span id='109'>109</span>
<span id='110'>110</span>
<span id='111'>111</span>
<span id='112'>112</span>
<span id='113'>113</span>
<span id='114'>114</span>
<span id='115'>115</span>
<span id='116'>116</span>
<span id='117'>117</span>
<span id='118'>118</span>
<span id='119'>119</span>
<span id='120'>120</span>
<span id='121'>121</span>
<span id='122'>122</span>
<span id='123'>123</span>
<span id='124'>124</span>
<span id='125'>125</span>
<span id='126'>126</span>
<span id='127'>127</span>
<span id='128'>128</span>
<span id='129'>129</span>
<span id='130'>130</span>
<span id='131'>131</span>
<span id='132'>132</span>
<span id='133'>133</span>
<span id='134'>134</span>
<span id='135'>135</span>
<span id='136'>136</span>
<span id='137'>137</span>
<span id='138'>138</span>
<span id='139'>139</span>
<span id='140'>140</span>
<span id='141'>141</span>
<span id='142'>142</span>
<span id='143'>143</span>
<span id='144'>144</span>
<span id='145'>145</span>
<span id='146'>146</span>
<span id='147'>147</span>
<span id='148'>148</span>
<span id='149'>149</span>
<span id='150'>150</span>
<span id='151'>151</span>
<span id='152'>152</span>
<span id='153'>153</span>
<span id='154'>154</span>
<span id='155'>155</span>
<span id='156'>156</span>
<span id='157'>157</span>
<span id='158'>158</span>
<span id='159'>159</span>
<span id='160'>160</span>
<span id='161'>161</span>
<span id='162'>162</span>
<span id='163'>163</span>
<span id='164'>164</span>
<span id='165'>165</span>
<span id='166'>166</span>
<span id='167'>167</span>
<span id='168'>168</span>
<span id='169'>169</span>
<span id='170'>170</span>
<span id='171'>171</span>
<span id='172'>172</span>
<span id='173'>173</span>
<span id='174'>174</span>
<span id='175'>175</span>
<span id='176'>176</span>
<span id='177'>177</span>
<span id='178'>178</span>
<span id='179'>179</span>
<span id='180'>180</span>
<span id='181'>181</span>
<span id='182'>182</span>
<span id='183'>183</span>
<span id='184'>184</span>
<span id='185'>185</span>
<span id='186'>186</span>
<span id='187'>187</span>
<span id='188'>188</span>
<span id='189'>189</span>
<span id='190'>190</span>
<span id='191'>191</span>
<span id='192'>192</span>
<span id='193'>193</span>
<span id='194'>194</span>
<span id='195'>195</span>
<span id='196'>196</span>
<span id='197'>197</span>
<span id='198'>198</span>
<span id='199'>199</span>
<span id='200'>200</span>
<span id='201'>201</span>
<span id='202'>202</span>
<span id='203'>203</span>
<span id='204'>204</span>
<span id='205'>205</span>
<span id='206'>206</span>
<span id='207'>207</span>
<span id='208'>208</span>
<span id='209'>209</span>
<span id='210'>210</span>
<span id='211'>211</span>
<span id='212'>212</span>
<span id='213'>213</span>
<span id='214'>214</span>
<span id='215'>215</span>
<span id='216'>216</span>
<span id='217'>217</span>
<span id='218'>218</span>
<span id='219'>219</span>
<span id='220'>220</span>
<span id='221'>221</span>
<span id='222'>222</span>
<span id='223'>223</span>
<span id='224'>224</span>
<span id='225'>225</span>
<span id='226'>226</span>
<span id='227'>227</span>
<span id='228'>228</span>
<span id='229'>229</span>
<span id='230'>230</span>
<span id='231'>231</span>
<span id='232'>232</span>
<span id='233'>233</span>
<span id='234'>234</span>
<span id='235'>235</span>
<span id='236'>236</span>
<span id='237'>237</span>
<span id='238'>238</span>
<span id='239'>239</span>
<span id='240'>240</span>
<span id='241'>241</span>
<span id='242'>242</span>
<span id='243'>243</span>
<span id='244'>244</span>
<span id='245'>245</span>
<span id='246'>246</span>
<span id='247'>247</span>
<span id='248'>248</span>
<span id='249'>249</span>
<span id='250'>250</span>
<span id='251'>251</span>
<span id='252'>252</span>
</pre><pre class='rust'>#[allow(dead_code)];

//! Precise GC on the heap.
//!
//! Very slow.

use ffi;
use ffi::GC_word;
use std::{mem, vec, libc, cell};
use std::unstable::intrinsics;

// macros from gc_typed.h

/// The size of the words understood by the GC, in bits.
#[inline]
pub fn GC_WORDSZ() -&gt; uint { 8 * mem::size_of::&lt;GC_word&gt;() }

fn GC_get_bit(bm: &amp;[GC_word], index: uint) -&gt; bool {
    let wrd_sz = GC_WORDSZ();
    ((bm[index / wrd_sz] &gt;&gt; (index % wrd_sz)) &amp; 1) == 1
}
fn GC_set_bit(bm: &amp;mut [GC_word], index: uint) {
    let wrd_sz = GC_WORDSZ();
    bm[index / wrd_sz] |= 1 &lt;&lt; (index % wrd_sz);
}
fn GC_WORD_LEN&lt;T&gt;() -&gt; uint { mem::size_of::&lt;T&gt;() / mem::size_of::&lt;GC_word&gt;() }

fn GC_BITMAP_SIZE&lt;T&gt;() -&gt; uint { (GC_WORD_LEN::&lt;T&gt;() + GC_WORDSZ() - 1) / GC_WORDSZ() }

/// Construct a tracing descriptor out of the `bitmap`, which should
/// be true for each word that is possibly a pointer.
pub fn make_descriptor(bitmap: &amp;[bool]) -&gt; ffi::GC_descr {
    // TODO, should make sure `bm` is long enough
    let wrd_sz = GC_WORDSZ();
    let l = bitmap.len();
    macro_rules! go (
        ($cmprs:expr) =&gt; { {
            let mut compressed = $cmprs;
            for (word_idx, &amp;is_ptr) in bitmap.iter().enumerate() {
                if is_ptr { GC_set_bit(compressed, word_idx) }
            }
            unsafe {
                ffi::GC_make_descriptor(compressed.as_mut_ptr(), l as GC_word)
            }
        } }
    );

    if l &lt; wrd_sz * 2 {
        go!([0 as GC_word, .. 2])
    } else {
        go!(vec::from_elem((l + wrd_sz - 1) / wrd_sz, 0 as GC_word))
    }
}

/// A pointer that uses type information to inform the GC about what
/// things could possibly be pointers, and what can just be ignored.
///
/// That is, run Boehm in precise-on-the-heap mode.
#[no_send]
#[deriving(Clone)]
pub struct GcTracing&lt;T&gt; {
    priv ptr: *mut T,
    //priv force_managed: Option&lt;@()&gt;
}

impl&lt;T: BoehmTraced&gt; GcTracing&lt;T&gt; {
    /// Create a new GcTracing.
    ///
    /// NB. this extracts the type information at runtime, for each
    /// allocation, and so is quite slow.
    ///
    /// TODO: fix that (requires compiler hooks)
    pub fn new(value: T) -&gt; GcTracing&lt;T&gt; {
        unsafe {
            let size = mem::size_of::&lt;T&gt;() as libc::size_t;

            let p = if cfg!(debug) {
                ffi::GC_debug_malloc(size, bytes!(&quot;GcTracing&quot;, 0).as_ptr() as *i8, 0)
            } else {
                ffi::GC_malloc_explicitly_typed(size,
                                                BoehmTraced::get_tracing_descr(None::&lt;T&gt;))
            } as *mut T;

            if p.is_null() {
                fail!(&quot;Could not allocate&quot;)
            }
            intrinsics::move_val_init(&amp;mut *p, value);
            GcTracing {
                ptr: p,
                //force_managed: None
            }
        }
    }

    #[inline]
    pub fn borrow&lt;&#39;r&gt;(&amp;&#39;r self) -&gt; &amp;&#39;r T {
        unsafe {
            &amp;*self.ptr
        }
    }
}

/// Values that the precise-on-heap Boehm collector can understand.
///
/// This trait is a stop-gap until the compiler itself can generate
/// such information, since writing these by hand is annoying, and
/// nearly impossible to get correct without dirty hacks to find
/// alignment of fields and extract (for example) the enum
/// optimisation that have occurred (and even then, they&#39;re likely to
/// no be correct).
pub trait BoehmTraced {
    /// Construct the `GC_descr` of `Self`. This should not be
    /// overriden.
    fn get_tracing_descr(dummy: Option&lt;Self&gt;) -&gt; ffi::GC_descr {
        let sz = mem::size_of::&lt;Self&gt;() * 8;
        let wrd_sz = GC_WORDSZ();
        let num_words = sz / wrd_sz;

        if num_words &lt; 16 {
            let mut vec = [false, .. 16];
            BoehmTraced::indicate_ptr_words(dummy, vec);
            make_descriptor(vec.slice_to(num_words))
        } else {
            let mut vec = vec::from_elem(num_words, false);
            BoehmTraced::indicate_ptr_words(dummy, vec);
            make_descriptor(vec)
        }
    }

    /// Mark which words within `Self` can possibly hold relevant
    /// pointers (do *not* explicitly mark which words are not
    /// pointers).
    ///
    /// E.g. `struct Foo { x: uint, y: GcTracing&lt;uint&gt;, z:
    /// GcTracing&lt;uint&gt; }` should explicitly set `words[1]` and
    /// `words[2]` to `true` but leave `words[0]` untouched.
    ///
    /// As long as `get_tracing_descr` is not overridden,
    /// `words` is guaranteed to be large enough to hold all the words
    /// in the current type.
    fn indicate_ptr_words(_dummy: Option&lt;Self&gt;, words: &amp;mut [bool]);
}

impl&lt;T&gt; BoehmTraced for GcTracing&lt;T&gt; {
    #[inline]
    fn indicate_ptr_words(_dummy: Option&lt;GcTracing&lt;T&gt;&gt;, words: &amp;mut [bool]) {
        // GcTracing is one word, and is (clearly) a pointer relevant
        // to the GC.
        words[0] = true;
    }
}

// things that aren&#39;t pointers at all
macro_rules! no_ptr {
    ($($t:ty),*) =&gt; {
        $(
            impl BoehmTraced for $t {
                // no words are pointers
                #[inline]
                fn indicate_ptr_words(_: Option&lt;$t&gt;, _: &amp;mut [bool]) {}
            }
            )*
    }
}

no_ptr! {
    int, i8, i16, i32, i64,
    uint, u8, u16, u32, u64,

    f32, f64,

    ()
}

// paradoxically, these don&#39;t count as having GC pointer words.
impl&lt;T&gt; BoehmTraced for *T {
    #[inline]
    fn indicate_ptr_words(_: Option&lt;*T&gt;, _: &amp;mut [bool]) {}
}
impl&lt;T&gt; BoehmTraced for *mut T {
    #[inline]
    fn indicate_ptr_words(_: Option&lt;*mut T&gt;, _: &amp;mut [bool]) {}
}

// for interior mutability
impl&lt;T: BoehmTraced&gt; BoehmTraced for cell::RefCell&lt;T&gt; {
    #[inline]
    fn indicate_ptr_words(_dummy: Option&lt;cell::RefCell&lt;T&gt;&gt;, words: &amp;mut [bool]) {
        let l = words.len();
        // the last word is not a pointer, and is not part of the `T`.
        BoehmTraced::indicate_ptr_words(None::&lt;T&gt;, words.mut_slice_to(l - 1));
    }
}

// likely incorrect
impl&lt;T: BoehmTraced&gt; BoehmTraced for Option&lt;T&gt; {
    #[inline]
    fn indicate_ptr_words(_dummy: Option&lt;Option&lt;T&gt;&gt;, words: &amp;mut [bool]) {
        // what&#39;s this &quot;parametric polymorphism&quot; thing? ;)
        let discr_size = mem::size_of::&lt;Option&lt;T&gt;&gt;() - mem::size_of::&lt;T&gt;();

        if discr_size * 8 &gt;= GC_WORDSZ() {
            // we have a proper discriminant, so T might contain pointers
            BoehmTraced::indicate_ptr_words(None::&lt;T&gt;, words.mut_slice_from(1))
        } else {
            // we don&#39;t have a big discriminant, so we&#39;re either a
            // nullable pointer, or a small non-word aligned type. (In
            // the latter case, we don&#39;t contain any pointers so we
            // could probably actually elide this call... but we&#39;ll
            // just let the optimiser do that.)
            BoehmTraced::indicate_ptr_words(None::&lt;T&gt;, words)
        }
    }
}

// impls for fixed length vectors for a selection of lengths

macro_rules! fixedvec {
    ($($n:expr),*) =&gt; {
        $(
            impl&lt;T: BoehmTraced&gt; BoehmTraced for [T, .. $n] {
                fn indicate_ptr_words(_dummy: Option&lt;[T, .. $n]&gt;, words: &amp;mut [bool]) {
                    if $n == 0 { return }

                    let bits_per_step = 8 * mem::size_of::&lt;[T, .. $n]&gt;() / $n;
                    let words_per_step = bits_per_step / GC_WORDSZ();
                    if words_per_step &gt; 0 {
                        for chunk in words.mut_slice_to(words_per_step * $n)
                            .mut_chunks(words_per_step) {
                            BoehmTraced::indicate_ptr_words(None::&lt;T&gt;, chunk)
                        }
                    }
                }
            }
            )*
    }
}

macro_rules! fixedvec_lots {
    (; $($n:tt),*) =&gt; { fixedvec!($($n),*) };
    ([$e:expr] $([$x:expr])* ; $($n:tt),*) =&gt; {
        // binary expansion
        fixedvec_lots!($([$x])* ; $( (2 * $n + 1), (2 * $n) ),*)
    }
}


// generate tracing info for all the short fixed length vectors.
// NB. this crashes rustdoc.
//fixedvec_lots!([1] [2] [4] [16] [32] [64]; 0)
// and some long ones
fixedvec!(100, 1000, 10_000, 100_000, 1_000_000)
</pre></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <script>
        var rootPath = "../../../../";
    </script>
    <script src="../../../../boehm/jquery.js"></script>
    <script src="../../../../boehm/search-index.js"></script>
    <script src="../../../../boehm/main.js"></script>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>
</body>
</html>
